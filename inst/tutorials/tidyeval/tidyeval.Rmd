---
title: Tidyeval
author: "Ian Lyttle, adapted from material by Lionel Henry and Hadley Wickham"
output: 
  learnr::tutorial:
    df_print: tibble
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library("learnr")
library("dplyr")
library("tibble")
library("glue")
library("learnr.tidyeval")

options(width = 100)
knitr::opts_chunk$set(comment = "#>")
```

## Introduction

Confession: for years, I have struggled to wrap my head around non-standard evaluation. I would sit down over a weekend and get myself to the point that I _thought_ I understood it, I _seemed_ to be able to write code to use it effectively, then a month later I would have no idea of what I had written or why it seemed to work. Here's a receipt:

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Personal <a href="https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw">#rstats</a> resolution: 2016 will be the year I wrap my head around non-standard evaluation (just like 2015, 2014, 2013, ...)</p>&mdash; Ian Lyttle (@ijlyttle) <a href="https://twitter.com/ijlyttle/status/682678320039899141?ref_src=twsrc%5Etfw">December 31, 2015</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

At first glance, tidyeval can seem just as mysterious - a new way to deal with non-standard evaluation. I came to appreciate that tidyeval is built on a series of principles; as I came to understand (at least some of) these principles, it became easier for me to retrace my steps and to take new ones. At this point I think I understand the basic principles such that, at the risk of telling you more than I know, I can discuss those basics here.

Of course, none of this material is possible without the work done by Lionel Henry and Hadley Wickham, who developed the tidyeval framework. Indeed, the examples shown here are adapted from their sources:

- [Programming with dplyr](http://dplyr.tidyverse.org/articles/programming.html)
- [Tidy evaluation](http://rlang.tidyverse.org/articles/tidy-evaluation.html)
- [Erratum tidyr 0.7.0](https://www.tidyverse.org/articles/2017/09/erratum-tidyr-0.7.0/)

I am particularly impressed with the "Erratum" article, as it explains very well the factors that went into a design choice, as well as the factors that went into the decision to modify that choice.

The goal of this tutorial is to make it easier for you to tackle these references.

As you go through this tutorial, please keep in mind that I am an imperfect interpeter of tidyeval principles. I will do my best to convey what I understand; any shortcomings are my sole responsibility, which I will recitify as they become apparent ([issue page](https://github.com/ijlyttle/learnr.tidyeval/issues)).

## What motivates tidyeval?

### Advantages

You are probably used to **dplyr** code that looks like this:

```{r}
filter(starwars, species == "Droid")
```

This does the same thing as base R code: 

```{r}
starwars[starwars$species == "Droid" &  !is.na(starwars$species), ]
```

The dplyr code is more concise - you don't have to repeat the name of the data frame, or specify that you don't want `NA` values.

As well, you may have used dplyr to access databases. If the `starwars` tibble were stored on a remote database, rather than in a local data-frame, dplyr would translate the expression `species == "Droid"` into SQL to obtain the same result. Tidyeval is the framework that dplyr uses to adapt the expression to the situation, so that "it just works".

### Things to keep in mind

However, as [Jar Jar discovered](https://youtu.be/qL1fBDQXSy8?t=1m40s), there is no such thing as a free lunch. There are a couple things to be mindful of.

#### Referential transparency

Most arguments to dplyr functions are not [__referentially transparent__](https://en.wikipedia.org/wiki/Referential_transparency). You can't replace an argument with a seemingly-equivalent argument that you have defined elsewhere.

##### Your turn

Let's look again at our earlier example:

```{r}
filter(starwars, species == "Droid")
```

Try the following substitutions and see what happens:

```{r eval=FALSE}
my_var <- species
filter(starwars, my_var == "Droid")

my_var <- "species"
filter(starwars, my_var == "Droid")
```

```{r starwars-my_var, exercise=TRUE}
filter(starwars, species == "Droid")
```

As you see, neither of these substitutions works how we expect - so it is not obvious how to call dplyr functions without hard-coding everything.

#### Ambiguity

As well, dplyr evaluates expressions ambiguously. As we will see, the code `filter(df, x == y)` can be interpreted differently depending on the data and the context:

```{r eval=FALSE}
df[df$x == df$y, ]
df[df$x == y, ]
df[x == df$y, ]
df[x == y, ]
```

If the "wrong" thing happens when you are working interactively, you can see that there is a problem and correct it. If the "wrong" thing happens when you are calling a function (from a function, from a packge, ...), it can be nearly impossible to figure out what went wrong, let alone fix it.

##### Your turn

Let's say we want to look at the Star Wars characters, comparing eye-color and hair-color.

In the code-block below:

1. Run the code as-is.
1. Uncomment the `eye_color == "black"` line, rerun.
1. Uncomment the `my_color == "black"` line, change the filter expression to `hair_color == my_color`, rerun.
1. Fiddle around with other varaibles and filter expressions.

What can you tell about the rules that `dplyr::filter()` uses to evaluate an expression?

```{r starwars-eye-hair, exercise=TRUE}
# eye_color <- "black"
# my_color <- "black"   
filter(starwars, hair_color == eye_color)
```

### Summary

Tidyeval provides a set of rules for the default evaluation of expressions, and a set of tools that let you change that default whenever you need to. For people who write functions and people who use those functions, tidyeval provides a framework that allows both sets of people be confident that a function will do what they expect it to do.

In the next few sections, we will discuss the principles and concepts of tidyeval, then show how you can use these to call functions that use tidyeval (like those in dplyr). Finally, we will discuss how you can write functions that use the tidyeval framework.

## Principles and concepts

We can demonstrate tidyeval's central idea using strings. Let's say that we want to compose a string to include a name that we specify elsewhere. This warm-up example is lifted from the [dplyr programming vignette](http://dplyr.tidyverse.org/articles/programming.html).

##### Your turn

In the excercise below, you will see that our first attempt is clearly doomed. Comment and un-comment the following lines to see some approaches we can use to compose the string that we expect. Maybe try some compoistions of your own...

In your own words, why does the first attempt fail, while the other two succeed?

```{r warm-up, exercise=TRUE}
name <- "not Hadley"

"How do you do, name?"

# paste0("How do you do, ", name, "?")

# library("glue")
# glue("How do you do, {name}?")
```

In the first attempt, we cannot evaluate the name because it is "quoted": the string itself is simply a value. In the second attempt, we build up the string piece-by-piece: `paste0()` evaluates `name` within the larger set of expressions. In the third attempt we use the __glue__ package, which allows us to compose a string by "unquoting": `{name}` is replaced with value of `name`, using the context from which `glue()` is called.

It may be useful to establish some vocabulary terms: values, expressions, and symbols.

### Values, expressions, and symbols (oh my!)

This may be a good time to recall the [famous quote from _Advanced R_](https://adv-r.hadley.nz/functions.html#all-calls):

> “To understand computations in R, two slogans are helpful:
> 
> Everything that exists is an object.
> Everything that happens is a function call."
> — John Chambers

Here, we will go over three important kinds of objects in the tideval framework.

A __value__ is something that has a defined, well, value. Types of values are logicals, doubles, integers, characters, and so on. With a value, everything has been evaluated - there is nothing left to define. Here's an example:

```{r}
is_droid <- starwars$species == "Droid" & !is.na(starwars$species)

is_droid
```

You can send these values as an argument to dplyr's `filter()` function:

```{r}
filter(starwars, is_droid)
```

As you can see, `filter()` is perfectly happy to take this set of values and return the data frame - but that's not why dplyr functions are so useful. We are accustomed to using dplyr like this:

```{r}
filter(starwars, species == "Droid")
```

Here, we used an __expression__, `species == "Droid"`; it is then `filter()`'s job to evaluate expressions into values - then use those values to return the corresponding rows of the data frame.

As we have found out, when dplyr evaluates an expression, its default is to look for variable-names first in the data frame, then in the context from which you called the function. Going forward, we will go through some examples of how you can use tidyeval to build expressions that are evaluated according to _your_ specifications.

You can build expressions using __symbols__; in this case, `species` is a symbol. Let's say you are building a shiny app where you need to call a dplyr function on a data frame that you upload to the app. When you are writing the app, you cannot possibly know the variable names that will be used at runtime. 

It may appear to make it difficult to compose an expression for dplyr to evaluate. We will see how the tidyeval framework lets you build expressions using symbols that you can create at runtime.

### Quosures

If you are already a little familiar with tidyeval, you have heard about __quosures__. These are the central feature of tidyeval. 

However, I'm not going to say too much about quosures just yet. In the Star Wars movies, Yoda was not introduced until the second movie was released, even though he is a pivotal character.

For now, it may be useful to think about a quosure as an expression that carries along with it the context where it was created. We will look at quosures more explicitly later in this tutorial.

> "Patience, for the Jedi it is time to eat as well." - a certain Jedi Master

## Tidyeval and tidyverse 

One of the mantras of the tidyverse is "data first!" 

This commonly refers to design of tidyverse functions where a data-frame is the first argument; this makes it easy to use the pipe operator. For example, let's find the youngest character(s) from each species.

```{r}
birth_year <- c(15, 19) # what if filter() did not look at data first?

starwars %>%
  select(name, species, birth_year) %>%
  group_by(species) %>%
  filter(birth_year == min(birth_year, na.rm = TRUE)) 
```

As you can see, we can interpret "data first!" another way: when a tidyverse function evaluates an expression, it looks in the _data first_, then the calling context. By following this rule, it becomes easier to work with tidyverse functions because they behave consistently according to a convention.

In the remainder of this tutorial, we are going to use tidyeval with dplyr functions: first calling them directly, then writing functions that call dplyr functions. One thing to keep in mind going forward, we are restricting ourselves to using these functions when the data-source is a local data frame. I understand that these priciples extend to using other data sources such as remote databases, but I am not your best guide to these other situations.

## Using functions that use tidyeval

### "selecty" functions

### "namey" functions

## Writing functions that use tidyeval

## More stuff




